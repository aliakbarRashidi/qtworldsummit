{
  "698": {
    "id": 698,
    "presentation": {
      "title": "Qt and Windows 10",
      "abstract": "<p>Microsoft went through a significant technology and focus shift recently, unifying their platforms towards Windows 10 everywhere. However, there is a lot of confusion what this actually implies to companies and individual developers. </p>\n<p>What versions of Windows 10 will exist (Windows 10 Home/Pro, Windows 10 Mobile (Enterprise), Windows 10 IoT Core, …)? How do they relate to each other? What is the situation on embedded and mobile, and with Microsoft's Internet of Things strategy? And lastly, what happens to existing Qt solutions, and what is the Qt offering for the whole Windows 10 ecosystem?</p>\n<p>This talks aims to provide a quick and easy-to-follow summary on the Microsoft product strategy and more importantly how Qt fits into this picture.</p>\n<p>Qt is the layer providing stability against platform changes, either from the platform vendor or project related requirements changing. By using Qt the project is not tied to a specific platform, even more it easily allows to transform an application project towards an embedded system.</p>\n<p>This is part 1 of Windows 10 related submissions. Part 2 will talk about the technical details to use Qt on Windows 10.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Maurice Kalinowski",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "699": {
    "id": 699,
    "presentation": {
      "title": "Qt’s Web Offering – An Overview",
      "abstract": "<p>Qt provides several components for integrating or interfacing with web content.<br />\nWith Qt WebEngine we have a very strong offering for HTML5 content that supports many different web technologies. This in particular includes WebRTC, WebGL and WebSockets. However, Qt WebEngine is not the only web related offering that is provided with Qt. There is also a Qt WebView module, which provides a consistent API for native web views and falls back to Qt WebEngine, if a native web view is not available. Qt WebChannel can be used to expose QObjects to any JavaScript context and thereby allows the development of a whole range of hybrid applications. The Qt WebSockets module provides an implementation of the WebSocket protocol, allowing us to communicate with WebSocket services or to implement a WebSocket service using C++ and QML API.</p>\n<p>In this talk we will provide a quick overview of these components, discuss their functionality and outline some potential use cases for the web-related components and technologies provided by Qt.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Allan Jensen",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "702": {
    "id": 702,
    "presentation": {
      "title": "Creating IoT applications with Bluetooth Low Energy and Qt",
      "abstract": "<p>Over 10 billion devices which use Bluetooth were shipped in the technology's first 10 years. But in 2013 alone, a further 2.5 billion new Bluetooth devices materialised and more than 3 billion in 2014. Bluetooth is going through what has been described as \"quiet revolution\", with massive and increasing levels of adoption driven by the release of the latest version of Bluetooth called \"Bluetooth Smart\".  Bluetooth Smart enables some exciting and very current technology trends such as IoT (Internet of Things), Wearable Technology, the Smart Home and Beacons.</p>\n<p>Goldman Sachs wrote an interesting report which categorised the growth of the internet as progressing through three “waves”. In the first wave, one billion PCs were connected to the internet. In the second, smart phones took us to two billion devices. But in the third wave…. the Internet of Things, they forecast there will be 18 billion devices connected to the internet by 2020. And Bluetooth Smart is the killer wireless enabler for the IoT so learning about Bluetooth Smart is a must for any developer set on exploiting the biggest opportunity we’ve seen in a long time!</p>\n<p>In this session you will learn about the fundamental concepts and architecture of Bluetooth Smart, how the Qt APIs make Bluetooth Smart capabilities available to applications and about tools that will help you. There will be slides. There will be code. There may even be demos :-)</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Martin Woolley",
      "organization": "Bluetooth SIG",
      "bio": ""
    }
  },
  "703": {
    "id": 703,
    "presentation": {
      "title": "Rising Trends in 3D in user interfaces",
      "abstract": "<p>For the past 20 years, Qt has delivered all the tools and libraries for creating the best possible user experience for your end users, from classic desktop look-and-feel to fluent, modern touch-based user interfaces. Today, the future of UIs is pointing towards 3D.</p>\n<p>We are seeing unprecedented development in Augmented Reality and Virtual Reality both in display technologies and 3D depth sensing of the surrounding environment. Combining these enables immersive user experiences as we have already seen in products like Microsoft HoloLens and Oculus Rift. Also the user interaction will change as gesture interaction with 3D elements is providing a more natural way of interacting with 3D objects.</p>\n<p>It has been possible to integrate 3D content with Qt UIs easily. Starting from Qt 5.5 creating and integrating 3D content is even easier with the new 3D modules: Qt Canvas3D and Qt 3D. Canvas3D enables you to leverage the innovation around WebGL and utilize JavaScript 3D libraries such as three.js. This enables easy sharing of 3D content and functionality for example across web and native applications. Qt3D on the other hand provides an extensible, flexible and data driven architecture which enables quickly implementing any rendering pipeline.</p>\n<p>This talk highlights the use cases we see now and in the future around 3D and introduces how Qt is meeting the needs of the modern 3D user interfaces. The focus of the talk is more on the use of 3D instead of the underlying technology and code.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Sami Makkonen",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "704": {
    "id": 704,
    "presentation": {
      "title": "Building Desktop and Embedded Uis with Qt 3D",
      "abstract": "<p>Qt3D is available as a Technology Preview with Qt 5.5 and is targeting Qt 5.6 for an initial release. Qt3D provides C++ and QML APIs to allow the easy creation and integration of compelling 3D content in your Qt-based applications without having to invest time into writing a generic 3D renderer.</p>\n<p>In this live coding session we will show how to use Qt3D along with other Qt facilities to create an impressive modern user interface that combines OpenGL-based 3D content with a Qt Quick 2 user interface. We will also show techniques for integrating this with backend business logic.</p>\n<p>This session will cover the Qt3D object model and hierarchical scene graph to manage nested transformations; custom materials and shaders that can be used to achieve just the look you are after; how to create and import new geometry into your virtual world; and how to get good performance using modern GPU features.</p>\n<p>The renderer in Qt3D is completely configurable from QML and C++ APIs by means of providing a so-called, framegraph. This allows Qt3D to be configured dynamically at runtime to control the OpenGL pipeline to achieve customised rendering algorithms, special effects and post processing. We will demonstrate some interesting ways of using this flexibility within the application being built.</p>\n<p>Qt3D provides more than a 3D renderer. It is also a general purpose, soft-realtime simulation framework built on top of a highly multithreaded architecture. We will introduce some of the concepts and architecture and show how to extend Qt3D to incorporate your own features as 1st class citizens in Qt3D.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Sean Harmer, Dr.",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "705": {
    "id": 705,
    "presentation": {
      "title": "Choosing the right Embedded Linux platform for your next project",
      "abstract": "<p>Getting started with Embedded Linux development can easily get complicated: after the initial headache of system images and cross-compilation, one has to deal with the question of windowing systems, the often vendor-specific bits of OpenGL integration, the handling of touch and other forms of input, the various approaches to multimedia acceleration, and many advanced, often halfway or not at all supported, use cases like outputting to multiple screens.</p>\n<p>Choosing the right embedded board and software stack is critical to the success of any project. While Qt frees developers from many of the board and vendor-specific issues of accelerated graphics, input devices and multimedia, allowing them to focus on the applications they want to build, it is still important to have an understanding of the relevant concepts and technologies. If the hardware or drivers lack support for the desired environment, graphics, or input features, Qt will not be able to fix that on its own.</p>\n<p>In Qt 5.5 the support for Linux graphics and input stacks is wider than ever. If you ever wondered why your applications fail with cryptic \"Could not create the egl surface: error = 0x3003\" errors on your brand new development board, what the difference between fbdev and KMS is, why opening a new window aborts your embedded application, or why the touchscreen does not work, this talk is for you. We are going to have an overview of the relevant windowing systems and the various ways of getting accelerated graphics onto the screen in embedded systems, while keeping it all high level enough to make the talk suitable to everyone involved in the development of embedded systems.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Laszlo Agocs",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "706": {
    "id": 706,
    "presentation": {
      "title": "Qt for Device Creation",
      "abstract": "<p>Developing software for embedded devices presents many challenges.  The talk aims to layout what some of those challenges are how the Qt for Device Creation offering solves them.  We will discuss what tools are necessary to develop embedded software and what differences there are between each of the supported embedded platforms.  The talk will cover both the using the opensource version of Qt as well as the commercial version and what the differences are in the context of device creation.  Many live demonstrations will be used to illustrate how easy it is to develop software for embedded devices with Qt and its tooling.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Andy Nichols",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "707": {
    "id": 707,
    "presentation": {
      "title": "The Internet of Things: What Is It And Why Should I Care?",
      "abstract": "<p>Gartner, Inc. recently forecast that 4.9 billion connected devices will be in use in 2015, up 30 percent from 2014, and the number will reach 25 billion by 2020. They describe the Internet of Things (IoT) as \"a powerful force for business transformation, and its disruptive impact will be felt across all industries and all areas of society.\"</p>\n<p>What exactly is IoT? As a software developer, does it really represent something new? In this presentation I will give an overview of IoT, including:</p>\n<p>- What IoT is and is not<br />\n- Terminology<br />\n- Example products<br />\n- Projected growth and market opportunities<br />\n- What does it mean to software developers?<br />\n- Popular hardware platforms<br />\n- Key protocols, hardware technologies, and software frameworks<br />\n- Relevance to Qt<br />\n- Challenges and criticisms (e.g. security and privacy issues)<br />\n- References to learn more</p>\n<p>While this talk will be primarily aimed at developers, it will not be highly technical.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Jeff Tranter",
      "organization": "Integrated Computer Solutions, Inc.",
      "bio": ""
    }
  },
  "708": {
    "id": 708,
    "presentation": {
      "title": "Qt for the Internet of Things, where user experience design meets real-time embedded design",
      "abstract": "<p>Modern embedded designs are demanding feature-rich user interfaces, while simultaneously ensuring real-time constraints are met for the most demanding command and control systems at the edge of the Internet of Things (IoT). From the advent of embedded, embedded systems have always lagged behind the desktop environment in user interfaces, but things are changing. What was once rare, is now expected when a user interface is required.</p>\n<p>It not just about the user interface or the embedded system; what matters is the visualization of time-sensitive information that gives the user the ability to visualize data. Further, it is not just about visualization of that data, it is the interpretation of that data which is the key.</p>\n<p>How does a user quickly and accurately maintain the state of an embedded machine, while transporting the data to the cloud, or bringing data down from the cloud and aggregating it so that it allows the user to make quick and informed decisions based on that data? And how does a user accomplish this while maintaining deterministic behavior for real-time tasks, and leveraging the advanced features afforded with Qt on embedded hardware that has an OpenGL® ES capable GPU? This technology bridges the gap between a machine with limited resources and a dedicated function, and the visualization of the data it collects. And it does all of this with a seamless user interface that rivals the desktop environment.</p>\n<p>In this session, we will look at a typical embedded system using the Freescale i.MX6 running Wind River VxWorks real-time operating system, to execute both the rigorous needs of real-time systems coexisting with a smooth and feature-rich user interface. This session is about using Qt in embedded for visualization, organization, status, command and control at the edge of the IoT.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Stephen Olsen",
      "organization": "Wind River",
      "bio": ""
    }
  },
  "709": {
    "id": 709,
    "presentation": {
      "title": "Introduction to Qt Creator",
      "abstract": "<p>Qt Creator is a powerful IDE aimed at making you a more productive C++ and Qt programmer.</p>\n<p>This presentation shows how to use Qt Creator for your Qt development tasks, highlighting classic features as well as the new abilities of Qt Creator 3.4.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Tobias Hunger",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "710": {
    "id": 710,
    "presentation": {
      "title": "Getting started with Qt on Android",
      "abstract": "<p>In this session the attendees will be learn how to setup the environment, how to use Qt and Qt Creator to target Android devices and how to sign the application in order to prepare them for publishing on Android markets.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "BogDan Vatra",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "711": {
    "id": 711,
    "presentation": {
      "title": "Basic Networking with Qt",
      "abstract": "<p>This talk will introduce you to Qt's networking classes. It will show<br />\nhow you can use TCP and UDP sockets and servers and HTTP with Qt.<br />\nIt will explain how you can architecture a Qt application that is using<br />\nthe network. At the end of the talk we will have created a fully working<br />\nQt application that uses all of this functionality.<br />\n(Danger, live coding!)</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Markus Goetz",
      "organization": "Woboq GmbH",
      "bio": ""
    }
  },
  "712": {
    "id": 712,
    "presentation": {
      "title": "The 8 mistakes of QtQuick newcomers",
      "abstract": "<p>QtQuick is a declarative language for programming fluid user interfaces and in a short time it has become the de-facto standard for UI programming. It builds on the solid base of Qt and it allows unprecedented speed of prototyping and development.<br />\nThe basis for such speed is to be looked for in the declarative nature of the QML language, a JSON’s superset that also allows Javascript code; the resulting code is easy to grasp, modify and extend. Given these characteristics, many newcomers are productive in just a few days; however, most of them are accustomed to imperative languages, so they have difficulties in completely understanding and embracing the declarative essence of QML and they usually have a hard time in shifting their way of thinking. In my career I’ve seen that some are puzzled by the fuzzy behavior of Javascript, some try to create deep hierarchies of Components that mimic C++ software, a few forget about animations, while others still try to manage memory by hand.<br />\nIn this presentation we will go through the most common pitfalls that newcomers are likely to experience and we’ll see some useful patterns that allow to elegantly deal with them.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Luca Ottaviano",
      "organization": "Develer Srl",
      "bio": ""
    }
  },
  "713": {
    "id": 713,
    "presentation": {
      "title": "Wearable sensor platforms using Qt in the medical and sports/fitness industry",
      "abstract": "<p>The session will delve into the trends and challenges in building the sensor platforms of tomorrow on the example and development experiences of creating a dedicated high-end optical heart rate and fitness level monitor (PulseOn).</p>\n<p>Qt was used extensively throughout the development cycle of this connected device, and the session will follow all the stages of the PulseOn product development and how Qt was used in them. The session will go into details on how Qt's traditional strengths (cross-platform availability, fast development cycles) were utilized in R&D and product development phases of connected devices in the sports and medical fields like in the case of the PulseOn device. The importance of the use of Qt-friendly analytics in product development will be discussed and how it was used to refine and adapt product development in large deployment scenarios. It will also highlight the technology risks and today's challenges from the aspect of working with devices with very limited resources available to them. </p>\n<p>Finally, a demo of the PulseOn connected device will be shown, and how it was successfully integrated (using Qt) with different host systems, ranging from desktop computers (Linux) through mobile (Android) to embedded (Intel Edison board).</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Attila Csipa",
      "organization": "PulseOn oy",
      "bio": ""
    }
  },
  "714": {
    "id": 714,
    "presentation": {
      "title": "How we stopped using the mouse and started drawing molecules with our fingertips: not the usual porting story",
      "abstract": "<p>Porting to mobile a Qt desktop application that lets you draw molecules, crunches numbers, stores data, displays plot and graphs it’s something that goes far beyond converting a QWidget to a Qml component. You have to change user's perspective, merging what they expect from a mobile application with what they expect from a scientific software. You have to<br />\noutsource heavy computational parts and data storage. You have to code from scratch components that don’t exist yet in the Qml ecosystem.</p>\n<p>With the arrival of Qt 5 and the support for Android and iOS, we realized that simply moving our legacy code to the new version of the framework still keeping the QWidget approach wouldn’t be worth it: we needed to port our applications to Qml and open to a whole new set of platforms.</p>\n<p>In this talk you’ll get the lessons learned during a porting journey lasted more than 6 months, with particular reference to the following topics:</p>\n<p>- Rethink a complex user model for drawing molecules so that one can use their fingers on mobile and touch screens, still keeping it usable on a desktop through the mouse<br />\n- Moving heavy computations on the cloud using REST and OAuth2 to exchange data.<br />\n- Provide a theming system for the UI, following Material Design principles but keeping a good user experience on the desktop<br />\n- Refactor graphic and drawing components with a pixel independent approach<br />\n- Develop a brand new interactive 2D plot with Qml in mind</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Massimiliano Pippi",
      "organization": "Self employed",
      "bio": ""
    }
  },
  "715": {
    "id": 715,
    "presentation": {
      "title": "Behavior Driven GUI Testing of Embedded, Mobile and Desktop Qt HMIs",
      "abstract": "<p>The quality assurance of software projects with graphical user interfaces, esp. in multi-platform environment such as Qt, often reveals the weaknesses of a development process.</p>\n<p>Did developers and testers work towards a common goal? Does the result satisfy the customer's needs and requirements? How do the different parties communicate in case of disagreement?</p>\n<p>The problem often lies in overwhelming specification documents which developers do not follow. Testers may work totally disconnected from development. And customers only see the end results.</p>\n<p>The Behavior Driven Testing and Development approach attempts to solve this problem. With the established standard language Gherkin, described features and scenarios are understandable for technical and non-technical members. This provides a common language for all involved parties and a single document which serves as specification, documentation and tests - manual or automated.</p>\n<p>The presentation will illustrate this method in detail and show how it can be successfully applied to Qt projects spanning from Desktop to Mobile and Embedded. The focus of the presentation will be the cross-platform Qt GUI test automation of the defined features and scenarios.</p>\n<p>The presentation will conclude with a live demonstration showing how the discussed approach has been successfully used in a real world Qt HMI project.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Reginald Stadlbauer",
      "organization": "froglogic",
      "bio": ""
    }
  },
  "716": {
    "id": 716,
    "presentation": {
      "title": "How to Develop with Qt for Multiple Screen Resolutions and Increase & Measure your Cross-Platform App Success (Business Strategy Session)",
      "abstract": "<p>This session shows how to develop applications for multiple screen sizes, screen resolutions and form factors like phones, tablets and desktop PCs with Qt. We show how you can use the same code base, while having native-looking UIs across platforms. This involves tips for responsive design with Qt and a comparison when to use Qt Quick and in which cases C++ is the better choice.</p>\n<p>This talk will also explain which Qt components you can use to increase your application downloads and user retention. And how to measure the success of your apps across platforms.</p>\n<p>This presentation gives you a non-technical overview of the possibilities with Qt for multi-screen development. For an in-depth session with code examples see the technical second part of this presentation in the Qt Application Development & Device Creation Track.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Alex Leutgöb & Christian Feldbacher",
      "organization": "V-Play",
      "bio": ""
    }
  },
  "717": {
    "id": 717,
    "presentation": {
      "title": "Effective multi-platform development with Qt Creator, QBS, and QEMU",
      "abstract": "<p>Qt solves the most important challenge of cross-platform development by giving you a toolkit for running your application across multiple devices and operating systems. It doesn't dictate what platform or configuration to use for development, allowing you to freely choose which environment to work in. Some target platforms just aren't that forgiving, though, prompting the development team to invest in multiple PCs and additional hardware - even additional developers - to cover all corners of the device market. These added environments and context switches can cut into your efficiency and your bottom line.</p>\n<p>By leveraging Linux as the core of your development environment, you can extend your cross-platform effectiveness by reducing the burden of platform context switches. Utilizing the best IDE for the job (Qt Creator), a fast and coherent build system (QBS), and world-class virtualization (QEMU), the task of building for multiple targets can be simplified. Linux allows for a free and configurable base for getting the most out of your hardware when building and deploying inside virtualized, scriptable environments with QEMU. The Qt Build Suite (QBS) improves compilation times while greatly improving the developer experience associated with the tedium of managing large dependency trees and different toolchains and SDKs. Qt Creator gives you the optimal development environment for which to write your code, along with superior deployment and debugging tools. All of this under any window manager of your choice!</p>\n<p>This talk presents a foundation for combining different open source technologies to improve your effectiveness in authoring and deploying cross-platform. Have you ever been curious about building and deploying Windows or OS X applications under Linux? Perhaps you've wanted to port your large application to QBS, but just need the push to see how painless it really is? The goal of this talk is to encourage you to consider developer experience in your everyday workflow in order to think differently about how to manage your development and get the job done. It highlights the pain points of the native build process and gives cues to finding improving efficiency and developer happiness through FOSS tools and Qt.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Andrew Knight",
      "organization": "Intopalo",
      "bio": ""
    }
  },
  "718": {
    "id": 718,
    "presentation": {
      "title": "Qt in IoT context : connected alarm-clock",
      "abstract": "<p>This presentation aims at offering a Qt application connected to the Cloud on an embedded device, while highlighting some of Qt5 major  features (OpenGL acceleration, multitouch areas, shader effects…).<br />\nThis project highlights the following points:<br />\n-\tWebservices for getting weather, news, time, and other useful information as you wake<br />\n-\tCommunication with a WIFI bulb light for simulating a slowly rising light with a dedicated color<br />\nA live demo on an iMX6 embedded system will demonstrate the connected Qt alarm-clock.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Adrien Leravat",
      "organization": "Adeneo Embedded",
      "bio": ""
    }
  },
  "719": {
    "id": 719,
    "presentation": {
      "title": "How Qt Meets the Automotive Technology Requirements of Today, Tomorrow & Beyond",
      "abstract": "<p>Users expect a seamless customer experience between all their devices and services, even within the car. Qt powers multiple automotive infotainment systems and smart car dashboards. To bring content inside the car, Qt can be used as a full platform for software services and applications running on top of the car's operating system.</p>\n<p>Through Qt’s cross-platform functionality, the same services can be extended beyond the car’s own displays and into the passenger devices (BYOD). Qt’s features let you create premium entertainment solutions and modern in-vehicle user experiences requested by today’s demanding automotive customer. What’s more, Qt’s flexible architecture allows for manufacturers to adapt to the market’s quickly changing requirements and easily be able to comply with future specifications.  </p>\n<p>In this talk, we will discuss the automotive industry trends from a technology provider’s point of view: what are the challenges and how can we address them with Qt? What sort of user expectations are there towards modern automotive UX and applications and how to create an ecosystem using one technology.</p>\n<p>In essence, we will walk you through the Qt offering for automotive system creation, give you an overview of Qt as a platform with applications, tool chains and ecosystem creation possibilities and present our roadmap and partnerships around automotive.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Petteri Holländer",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "720": {
    "id": 720,
    "presentation": {
      "title": "Coding Qt for greater interoperability and portability – an introduction to the OpenCar platform",
      "abstract": "<p>In this presentation we will describe a modular architecture that enables automotive infotainment system integrators to more easily reuse Qt applications across various automaker projects. This approach enhances code portability, simplifies validation and packaging and enables over-the-air maintenance of automotive applications. We will also introduce the OpenCar platform, an in-car application framework, application development environment, online test and collaboration tools. You will learn how Qt can be extended through tight integration with OpenCar’s automotive infotainment framework.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Jeff Payne, CEO",
      "organization": "OpenCar Inc.",
      "bio": ""
    }
  },
  "723": {
    "id": 723,
    "presentation": {
      "title": "Revolutionizing Automotive with Qt",
      "abstract": "<p>The user interfaces in cars is undergoing a dramatical change right now. Touch screens, applications and beautiful, modern user interfaces are coming to a car close to you. For Qt, this is a perfect fit, but not without challenges. Automotive systems commonly consists of multiple displays, legacy technology, focus on hardware costs as well as legally controlled start-up times, long product cycles and more. Solving these issues with Qt means revolutionizing what you can expect from your next car - but also they way that automotive software is created.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Johan Thelin",
      "organization": "Pelagicore",
      "bio": ""
    }
  },
  "725": {
    "id": 725,
    "presentation": {
      "title": "In the Driver’s Seat – Tech Tales from the Automotive Sector",
      "abstract": "<p>Coming soon</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Louai Al-Khanji",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "726": {
    "id": 726,
    "presentation": {
      "title": "How to Implement an Automotive Infotainment System using Qt Quick",
      "abstract": "<p>Demand for connected devices in automobiles is accelerating as mobile ecosystems are maturing. The ability for automakers to differentiate in an increasingly competitive environment depends on its ability to integrate a smart in-vehicle infotainment (IVI) system strategy and deliver a fully connected lifestyle to consumers. The manufacturers who succeed at providing an open, scalable and easily configurable automotive IVI will be the future market leaders.</p>\n<p>Consumers expect the same user experience (UX) in their automobiles as on other personal devices that blend beauty and simplicity with practical use and technology. These increased expectations for design and performance also add complexities in interoperability and safety for the automaker.</p>\n<p>This talk describes the architecture and design of an IVI system written using the Qt(R)/Qt Quick framework running on the Intel(R) In-Vehicle Solutions compute module.  This application features:</p>\n<p>- A set of C++ classes including all IVI features that can be integrated with vastly different IVI visual designs,<br />\n- The ability to test all IVI functionality in isolation without any IVI,<br />\n- A set of loosely coupled native applications that can be plugged into the IVI system,<br />\n- The ability to deliver new applications without needing to modify, recompile or relink any existing IVI code,<br />\n- Easy customization of IVI application assets (graphics and colors) without needing to modify the IVI code,<br />\n- The ability for IVI to be translated and localized for worldwide deployment,<br />\n- Seamless integration with third-party supplied IVI functionality,<br />\n- Delivery of < 2 second start-up time and velvet smooth run time performance</p>\n<p>In particular, key architectural components will be covered:<br />\n- Layered Design<br />\n- Plug-in Architecture<br />\n- Surface Composition<br />\n- User Interface Templates<br />\n- Asset Management<br />\n- Make and Model Customization<br />\n- Screen Orientation<br />\n- Internationalization</p>\n<p>Any IVI system must run on specialized hardware and provide a responsive user experience while doing a variety of simultaneous tasks. Hardware displays range from small non-touch displays with hardwired buttons to large touch-sensitive screens. Vehicle manufacturers seek a global solution they can deploy across their entire product line which may feature different capabilities depending upon the model.  This also may mean different brands or styles.  In addition, their vehicles are sold worldwide and their IVI systems must support local languages and units.  Can all of this be done with one software platform? This presentation argues, yes!</p>\n<p>While the example used is an Automotive Infotainment System the concepts apply equally well to any application that requires on-the-fly color themes, user selectable localization, and run time selection of application functionality.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Dustin Kassman",
      "organization": "Integrated Computer Solutions, Inc.",
      "bio": ""
    }
  },
  "727": {
    "id": 727,
    "presentation": {
      "title": "Resolving Automotive UI Challenges With an Optimized Qt Implementation",
      "abstract": "<p>Diversity is the name of the game in today’s automotive development. In-car systems make use of UI technologies such as Qt, HTML5 and OpenGL. They incorporate frameworks from companies such as Crank Software, DiSTI Corporation, Elektrobit, HI Corporation, Rightware and 3D Incorporated, just to name a few. Infotainment systems are now also supporting projection mode technologies such as MirrorLink, Apple’s CarPlay and Google’s Android Auto. As the premier software supplier in the infotainment market with >50% market share (IHS Automotive, 2014), QNX Software Systems has extensive experience with all of these technologies, and all are supported on the QNX OS – but for a native HMI, QNX has selected and optimized Qt, and fully integrated it into the QNX CAR Platform for Infotainment. In this session, we will look at QNX’s work with Qt, system and development challenges in automotive, and the future of Qt as it is increasingly embraced by automakers and Tier 1 suppliers worldwide.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Grant Courville",
      "organization": "QNX Software Systems",
      "bio": ""
    }
  },
  "728": {
    "id": 728,
    "presentation": {
      "title": "Qt Canvas3D – Presenting the Pipeline",
      "abstract": "<p>Qt Canvas3D 1.0 was introduced as an official Qt module in Qt 5.5, after technology preview release with Qt 5.4. Canvas3D implements a WebGL-like API. It enables users to run 3D content implemented with WebGL based libraries and tooling pipelines directly inside QML JavaScript without requiring a HTML runtime to be present. It also enables sharing the 3D content including the models, textures, and JavaScript code between a HTML page and a native application.</p>\n<p>This talk will first introduce the new developments to Canvas3D we have coming in Qt 5.6. We have continued optimizing and further integrating Canvas3D with the Qt Quick scene graph renderer. This includes a rewrite of Canvas3D to move the OpenGL rendering calls to the scene graph render thread. This will enable better performance in multithreaded rendering environments and allow rendering of QML elements into textures that can then be used with the Canvas3D's rendering API.</p>\n<p>The session will also include a hands-on part that demonstrates how easy it is to get started with Canvas3D when combining it with a library like three.js that has been already ported to run on top of Canvas3D. The session shows the basics. Starting from how you can get the correct version of three.js, how to integrate the library with Canvas3D in your QML and JavaScript code, how to load 3D models in to your scene, how to load textures, how to build a scene with 3D objects, and how simple it is to start combining the 3D elements in the scene with QML state transition and animation.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Pasi Keränen",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "729": {
    "id": 729,
    "presentation": {
      "title": "Effective Qt",
      "abstract": "<p>For around two decades now, Scott Meyers' Effective C++ series forms an indispensable resource for even the most experienced C++ developer, and many of us own a copy. Its bite-sized items allow you to read one small chapter at a time, and return to your work, applying what you just learned right away.</p>\n<p>What was lacking was a similar resource for Qt development.</p>\n<p>In 2010, Marc Mutz started a series of blog posts under the series title Effective Qt (https://marcmutz.wordpress.com/effective-qt/), which, however, fell prey to paternity in 2012. It still generates a lot of traffic, so there continues to be demand for it.</p>\n<p>These blog-posts described the state as of Qt 4, while this session will target Qt 5, introducing new guidelines and updating existing advice on such varied topics as API design, performance, and code quality.</p>\n<p>Among other things, you will learn how to get the most out of the new QObject signal/slot connection syntax, and how to blaze a trail through the surprising complexity of QString creation.</p>\n<p>Participants are expected to have a working knowledge of Qt (specifically, QtCore).</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Marc Mutz",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "730": {
    "id": 730,
    "presentation": {
      "title": "Using the Qt Quick Scene Graph API",
      "abstract": "<p>The scene graph is the main change under the hood of QtQuick 2 that justified a new major version of the technology, while the rest initially remained similar to QtQuick 1. The extra performance is provided automatically for applications to enable smooth panning and scaling, but there are some situations where you can take advantage of using the scene graph API directly to smoothen your custom graphical item animations.</p>\n<p>This talk will present how the lower-level scene graph API in QtQuick can, with the help of a few lines of C++ code, allow you to reduce the overhead of QML abstractions and offload some transform computations to the GPU. In addition this will present:</p>\n<p>- What the scene graph is and how it relates to a QML component or QQuickItem.<br />\n- How it is different from a QGraphicsScene.<br />\n- How it interacts with OpenGL and the GPU.<br />\n- How you can write code to run safely in the render thread and taking advantage of the geometry batching done by the renderer.<br />\n- What APIs like QQuickItem::updatePaintNode, QSGNode, QSGGeometry, QSGMaterial and QSGTexture are used for.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Jocelyn Turcotte",
      "organization": "Woboq GmbH",
      "bio": ""
    }
  },
  "731": {
    "id": 731,
    "presentation": {
      "title": "How to Develop with Qt for Multiple Screen Resolutions and Increase & Measure your Cross-Platform App Success (In-Depth Tech Session)",
      "abstract": "<p>This session shows how to develop applications for multiple screen sizes, screen resolutions and form factors like phones, tablets and desktop PCs with Qt. We show how you can use the same code base, while having native-looking UIs across platforms. This involves tips for responsive design with Qt and a comparison when to use Qt Quick and in which cases C++ is the better choice.</p>\n<p>We cover dynamic image switching, content scaling and basic Qt Quick features like file selectors, Loader elements, Layouts, QML Singletons and property bindings and compare the use cases for each of them. In addition, we introduce a density-independent approach you can use to create Qt apps on different resolutions and screen densities.</p>\n<p>This talk also explains which Qt components you can use to increase your application downloads and user retention. And how to measure the success of your apps across platforms.</p>\n<p>This presentation gives you a technical overview with code snippets and hands-on examples of the possibilities with Qt for multi-screen development. For a non-technical overview of this topic, we recommend the first part of this presentation in the Qt Technology Strategy Track.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Alex Leutgöb & Christian Feldbacher",
      "organization": "V-Play",
      "bio": ""
    }
  },
  "732": {
    "id": 732,
    "presentation": {
      "title": "Optimizing Qt Applications",
      "abstract": "<p>The Qt libraries are highly versatile and offer a nice API for writing applications with. From simple graphical interfaces to complex client/server architectures, Qt offers the tools to get the job done.</p>\n<p>But, just like with any other abstraction, it is sometimes not straightforward what will happen behind the scenes. This can have detrimental effects on the performance of your application, when seemingly innocent code wreaks havoc on your cache lines, hardware threads are starved and the graphical interface freezes.</p>\n<p>This talk will look at such situations, shows you how to analyze the hotspots and presents solutions to some common performance pitfalls in Qt code.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Milian Wolff",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "733": {
    "id": 733,
    "presentation": {
      "title": "When all goes according to script",
      "abstract": "<p>Qt has had in-application scripting capabilities for a long time in the form of the QtScript module.</p>\n<p>With the deprecation of said module in Qt5.5, many have started looking for a successor.<br />\nQJSEngine and, by extension, its variant QQmlEngine, mostly famous for being at the core of Qt's outstanding QML technology, are the most obvious candidates.</p>\n<p>While neither is a drop-in replacement of the now deprecated QtScriptEngine, they do provide a state-of-the-art JavaScript implementation, with a wide range of easy to use integration points.</p>\n<p>Being explicitly designed for use with Qt and its object and introspection system does not only allow them to easily and efficiently bridge between the C++ and JavaScript worlds, it also puts them into a special position when it comes to supported platforms.</p>\n<p>While other engines, like Google's famous V8, cannot be used on platforms with certain restrictions, such as Apple's iOS, Qt's new engine, lovingly code-named V4, remains fully portable and supported as these restrictions have been part of all design and implementation considerations.</p>\n<p>This talk will focus on how to use these new facilities and common techniques for integrating with the application's data and functionality.<br />\nSpecial attentions will be drawn to how the capabilities inherent to the QML variant can make scripts even more versatile, elevating them from mere execution and computation helpers to powerful application add-ons.</p>\n<p>While QML is most well known for being the foundation for QtQuick based user interfaces,<br />\nit offers great opportunities for scripts in applications using QtWidgets, or not having any UI at all.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Kevin Krammer",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "734": {
    "id": 734,
    "presentation": {
      "title": "Writing better code with help from Qt and the compiler",
      "abstract": "<p>Traditionally, getting the most out of a processor required writing assembly code that used specialised instructions to accomplish some particular tasks. And though that's still widely used, processors are very complex and maintaining assembly code by hand is a hard and tedious task. Add to that the fact that processors evolve and getting the timings right of each generation is better left to the compiler.</p>\n<p>A little known feature of the compilers is that it is possible to get access to certain instructions from high-level C and C++ code, by way of intrinsic functions, thus allowing developers of native code to get very close to bare metal performance. Yet modern compilers can offer more functionality to help the bold developer write better code. For example, GCC can offer an automatic way of dispatching to different functions based on the architecture the code is being run on. Both GCC and the Intel compiler also allow code for multiple targets to be written in one single C or C++ source file, thereby allowing for better optimisation by way of inlines and dead code elimination.</p>\n<p>All is well and good if you know exactly which compiler you're using. When one has to deal with multiple compilers, like Qt routinely has to, things may get tricky. If the objective is to write optimal code for important, hot code paths, we don't want to settle for \"lowest common denominator\" of compiler support. To make sure we don't fall into that trap, Qt has a series of macros and both compile- and run-time processor feature detection support to generate the best code given the environment in use. </p>\n<p>This presentation will present those techniques and show which ones work on GCC, Clang, the Intel compiler and Microsoft Visual Studio. It will also show how to get more information on which intrinsics exist and what they do. It will draw heavily upon the presenter's experience implementing this very type of optimisations for Qt 5.3 and 5.3.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Thiago Macieira",
      "organization": "Intel",
      "bio": ""
    }
  },
  "735": {
    "id": 735,
    "presentation": {
      "title": "Qt for Native Client",
      "abstract": "<p>Native Client is a sandbox for running compiled C++ code securely and efficiently in the Chrome browser. The Qt for Native Client platform port allows compiling Qt applications as Portable Native Client executables, which can then be distributed via the web or on the Chrome App store to any system running the Chrome browser or Chrome OS.</p>\n<p>This talk will show how to use NaCl SDK and tools provided with Qt to create, debug, and deploy a web-distributable application using either Qt Widgets or Qt Quick. A key aspect will be highlighting the unique requirements and restrictions caused by the Native Client and browser sandboxes. Topics covered includes interaction with the hosting web page, OpenGL, Multimedia, network access and the Qt Quick runtime and playground.</p>\n<p>Qt for Native Client is available as a tech preview in source code form.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Morten Johan Sørvig",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "736": {
    "id": 736,
    "presentation": {
      "title": "Extending Qt on Android apps using JNI",
      "abstract": "<p>Why? Because it is impossible for Qt to implement all Android features e.g.:</p>\n<p> * listening for Android O.S. notifications:<br />\n    **   sd card notifications: bad removal, eject, mounted, unmounted, etc.<br />\n    **   network notifications: network up/down.<br />\n    **   battery level and charging state.<br />\n    **   etc.<br />\n * accessing Android O.S. features:<br />\n    **  telephony (Initiate calls, MMS, SMS, etc.)<br />\n    **  contacts<br />\n    **  speech (TTS and Speech Recognizer)<br />\n    **  system accounts<br />\n    **  system preferences<br />\n    **  NFC<br />\n    **  USB<br />\n    **  OBB</p>\n<p> * create own Android Activities and Services.</p>\n<p>The audience will learn how to extend their qt apps using JNI to access any Android features that are not available on Qt. </p>\n<p>Previous knowledge about Qt, threads & Android API is needed.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "BogDan Vatra",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "737": {
    "id": 737,
    "presentation": {
      "title": "Virtual Keyboards for Qt applications",
      "abstract": "<p>With touch screen devices gaining more and more popularity, there is the increasing need  to support text input via virtual keyboards.</p>\n<p>In this session we will explore different requirements for virtual keyboards and we will have a look at different options to integrate a virtual keyboard into Qt Widgets and Qt QML applications depending on these requirements with the Qt Platform Abstraction API for different platforms like eglfs, X and Wayland.</p>\n<p>We will have a look at some existent virtual keyboards like the Qt Virtual Keyboard and some Qt open source solutions. We will also see how a custom virtual keyboard could be created from scratch.</p>\n<p>We will look at some advanced features of virtual keyboards like support for different layouts, support for text correction and prediction and support for multiple languages especially CJK languages. </p>\n<p>We will see how the Qt input method API can be used on application side to improve the user experience with virtual keyboards.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Tobias König",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "738": {
    "id": 738,
    "presentation": {
      "title": "Contributing your first patch to the Qt Project",
      "abstract": "<p>The Qt Project has been up and running for over three years now and has released Qt from 4.8 through 5.3 with a community of developers interested in making Qt a better product. That was not an accident. So how does one join in \"the fun\"? New contributors to Qt will want to know what the requirements are for the first patch they submit, like how to format it properly, what they should and should not modify in the source code, what the coding style is, how to nurse it through acceptance in the Qt Project infrastructure, etc.</p>\n<p>Full Abstract:</p>\n<p>Joining an established team of developers can be a daunting task for a lot of reasons, ranging from unfamiliarity with the code itself, through ignorance of existing practices, to difficulty fitting in with the personalities. It gets more difficult when we're talking about an Open Source Project, with contributors all over the world, few of whom are native English speakers.</p>\n<p>Those are not showstoppers, though. Not for the Qt Project: created to drive the development of Qt and other related projects, we strive to make it easier for newcomers to participate (this presentation being one such way). In this session, we will try to address issues like:</p>\n<p>   * overview of the Qt Project and decision-making<br />\n   * how to obtain the Qt source code in a form suitable for modification (i.e., \"cloning from Git\")<br />\n   * the Qt coding style and library coding policies<br />\n   * making changes to Qt and testing them<br />\n   * dealing with cross-platform issues and what one really needs to know<br />\n   * submitting to the Qt code review system and reviewing with other developers (\"pushing to Gerrit\")<br />\n   * submitting the change through Qt's Continuous Integration system<br />\n   * API reviews, timelines, roadmaps</p>\n<p>There will be ample time at the end of the presentation for questions and discussions.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Thiago Macieira",
      "organization": "Intel",
      "bio": ""
    }
  },
  "739": {
    "id": 739,
    "presentation": {
      "title": "using namespace std;",
      "abstract": "<p>There is some overlap between features provided by Qt and those provided by the C++ standard library (classes in the std namespace). Some Qt developers are even a little afraid of using the standard library, while some others are criticizing Qt for not playing well with the standard. In this talk we will see the differences and similarities between Qt and the standard library, and how they complement each other. We will look at how to make better use of the standard library in your Qt application. It is a technical talk in which you will learn both about the Qt core classes and standard classes.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Olivier Goffart",
      "organization": "Woboq GmbH",
      "bio": ""
    }
  },
  "740": {
    "id": 740,
    "presentation": {
      "title": "Developing for Windows 10 With Qt",
      "abstract": "<p>This is part 2 of Windows 10 related submissions and will go into technical details.</p>\n<p>Windows 10 has been released in summer 2015 and Qt welcomes this new version by providing full support for it. </p>\n<p>However, some considerations might be needed to get the most out of your project and get started developing for Windows 10.</p>\n<p>This talk will give a detailed overview of getting started with Qt and Windows 10. A project will be compiled, deployed and run on desktop, mobile as well as Windows 10 IoT Core (most likely Raspberry Pi2).</p>\n<p>Following that a couple of descriptions for Windows 10 related packaging will be presented. How does the sandboxing look like on Windows 10? What are Universal Binaries and what kind of support does Qt provide for them. Also all steps required for publishing to the Windows Store will be explained.</p>\n<p>The last section talks about moving existing projects to Windows 10, first running on desktop and then later on embedded. A couple of options and parameters might be required to successfully launch the project under the new environment. In some cases such a “port” from one Windows version to another might not even be required. The pros and cons will be presented as well too.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Maurice Kalinowski",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "741": {
    "id": 741,
    "presentation": {
      "title": "Qt on iOS A to Z",
      "abstract": "<p>Since version 5.2, Qt has been available on iOS. In this talk, we go through the process of building a simple QML application, run in the simulator, deploy to a device, push to the app store.</p>\n<p>We first look at the creator project and settings that are specific to iOS such as targeted devices, SDKs, required capabilities, etc. We also look at Qt Creator tooling related to simulator and devices deployment. We will also mention where Xcode is still needed, such as the initial code signing setup and the App Store submission process.</p>\n<p>After looking at a simple QML app, we investigate the coverage Qt relative to the native capabilities. In particular we'll focus on text editing, keyboard customising, keyboard avoidance, accessing the sensors (location, orientation, camera), etc.</p>\n<p>Then we look at how integrating with the native toolkits for accessing feature not covered by the QML layer. Using Objective C++ and Qt's iOS specific integration layer, we show how to access features from UIKit, and other native libraries.</p>\n<p>Finally, we will look at setting up projects to build shared components based on Qt in order to builds app extensions.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Mike Krus",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "742": {
    "id": 742,
    "presentation": {
      "title": "Qt Quick Controls Re-engineered",
      "abstract": "<p>Qt Quick enables rapid development of fluid UIs and provides all the elements necessary for creating user interfaces with QML.</p>\n<p>This talk will cover the use of Qt Quick Controls, a reusable set of UI components based on Qt Quick, and concentrate on best practices for rapid UI development for all types of applications with a focus on embedded platforms. We will cover the second generation of Controls and its new and improved architecture.</p>\n<p>We will explore how to create an application's UI with optimal code re-use by making use of existing components and the Qt Quick Controls. At the same time the branding and customizing of the application to a specific design will be taken into account. Another important aspect is the combination of QML and C++.</p>\n<p>The presentation assumes the audience has basic Qt Quick knowledge.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Gabriel de Dietrich",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "743": {
    "id": 743,
    "presentation": {
      "title": "Integrating OpenGL with Qt Quick 2 applications",
      "abstract": "<p>One of the foundation pillars of Qt Quick 2 is its OpenGL-based rendering pipeline. By leveraging the GPU capabilities, we get 60 frames-per-second animated scenes, real time eye candy and special effects, particles, and so on. Moreover, the main programming language is QML, which is extremely popular amongst developers and designers -- it allows them to quickly prototype and build user interfaces. For these reasons, Qt Quick is becoming the de-facto choice on mobile and embedded platforms.</p>\n<p>However, can we integrate Qt Quick 2 with an existing OpenGL codebase? Would it be possible to reuse old, working, tested OpenGL code and give it a new look and feel by building a Qt Quick interface that uses it? How far can we go with that integration?</p>\n<p>In this talk, I will show the technologies available in Qt 5.4 / 5.5 that allow deep integration of Qt Quick 2 scenes with custom drawn OpenGL content. We will discuss the possibility of simply providing a Qt Quick overlay for an OpenGL scene.  The discussion will then proceed to the creation of custom Qt Quick Items drawn using raw OpenGL commands, which can then be used from QML.  Finally, I will illustrate how to manually drive Qt Quick's own rendering if we need to be in complete control of how and when the rendering happens.</p>\n<p>The audience is expected to have familiarity with basic QtQuick and OpenGL concepts, but no in-depth knowledge of them is required.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Giuseppe D'Angelo",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "744": {
    "id": 744,
    "presentation": {
      "title": "High-dpi Qt",
      "abstract": "<p>Supporting different display pixel densities is now as important as supporting different display sizes. This talk will give an overview of the existing and future high-dpi support in Qt. It will go into detail on several topics:</p>\n<p>- An introduction to the high-dpi scaling mode, also comparing it to traditional DPI scaling.<br />\n- Platform support and Qt configuration options<br />\n- Overview of API additions to Qt.<br />\n- Best practices for applications, including how to handle raster graphics assets.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Morten Johan Sørvig",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "745": {
    "id": 745,
    "presentation": {
      "title": "Qt, multimedia, and computer vision – a great match for Embedded Linux",
      "abstract": "<p>In this live coding session we are going to build a cross-platform computer vision application utilizing the camera. Based on Qt Quick Controls, Qt Multimedia, and OpenCV, the application will run both on desktop platforms and Embedded Linux. The application will be developed in Qt Creator and deployed onto an i.MX6-based board running the software stack provided by Qt for Device Creation.</p>\n<p>Qt Multimedia makes creating Qt Quick applications featuring accelerated video and camera streams as a natural part of their user interface quick and painless. The new video filtering features of Qt 5.5 further enhance these capabilities: integrating 3rd party vision and image processing frameworks, like OpenCV, or accelerated algorithms implemented with GPU compute APIs, like OpenCL and CUDA, is now made simple and efficient.</p>\n<p>OpenCV (Open Source Computer Vision Library) a BSD-licensed computer vision and machine learning software library with more than 2500 optimized algorithms. Application areas include object detection, motion tracking and estimation, facial and gesture recognition, machine learning, and others. Computer vision is an area of continuously increasing focus in the mobile and embedded world. Its role is central in automotive, robotics, and augmented reality. Being a C++ framework, Qt allows easy and straightforward usage of external libraries like OpenCV.</p>\n<p>Combined with the touch-friendly user interface elements of Qt Quick Controls and the Flat style, Qt becomes an excellent choice for applications and embedded products utilizing computer vision algorithms. It is now time to see all this in action.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Laszlo Agocs",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "746": {
    "id": 746,
    "presentation": {
      "title": "Building Location Analytics and Mapping into Your Apps",
      "abstract": "<p>Geolocation is a must-have element of any modern application design today. More and more applications are becoming location-aware, and the demand for geographic content, maps and functionality in mission-critical workflows is increasing all the time.  Developers need complete geolocation APIs and SDKs to build apps that can visualize and analyze maps and mapping data, and support the end user in making the most informative decisions in any situation. These SDKs must be productive, in that they are easy and intuitive to develop applications and solutions with. They must be able to build great user experiences, intuitive, easy to use, GUI and non GUI-based apps that are versatile enough to work with geo-enabled Web Services as well as data and maps that reside locally on a device, simultaneously.  These are just some of the key elements that today’s app developers need in a developer toolset.</p>\n<p>Esri’s ArcGIS Runtime SDK for Qt is a developer kit that provides all of the crucial tools and APIs for building great location-aware apps. It extends the Qt framework to assist in creating highly functional apps that can have both rich mapping and analytical capabilities, optimized to run on multiple platforms and devices, from Android, Mac and iOS devices to Windows and Linux desktops and embedded systems. This presentation discusses and demonstrates Esri’s rich, geospatial Runtime Qt SDK. Demonstrated capabilities include:</p>\n<p>- Mapping and Visualization<br />\n- Collecting, editing and managing geographic business data, online or offline</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Michael Tims",
      "organization": "ESRI",
      "bio": ""
    }
  },
  "747": {
    "id": 747,
    "presentation": {
      "title": "The CPU Usage Analyzer for Device Creation",
      "abstract": "<p>The usual approach to analyzing the CPU usage of Linux-based Qt applications is running them through valgrind, using the \"callgrind\" tool. This works well for Desktop applications and provides very accurate statistics on how an application spends its CPU time. However, for embedded devices with limited resources valgrind is not the best choice. Also, such statistics do not show the<br />\ninteraction between different threads or distinguish between idle and busy periods during the run time of an application.</p>\n<p>QtCreator 3.4 has a new CPU Usage Analyzer, specially targeted for Device Creation. It will be enabled with Boot2Qt 5.5 and it allows you to get a detailed picture of the functions where your application spends its time.</p>\n<p>The CPU Usage Analyzer provides a zoomable timeline view like the QML Profiler, so that you can see what functions are running in what threads at any given time. In future releases a statistics view will be added. The data is collected with the Linux perf tool, which is less accurate but much faster than valgrind. This way meaningful data can be collected even on resource-constrained devices.</p>\n<p>The talk will showcase the new functionality in a live demo.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Ulf Herman",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "748": {
    "id": 748,
    "presentation": {
      "title": "A deep dive into QML memory management internals",
      "abstract": "<p>Thanks to garbage collection, memory management in QML is (mostly) automatic. The application developer is relieved from the error prone task of manually taking care of memory. The drawback to this convenience is a distinctive loss of control over the handling of memory by the application developer and an overall intransparency towards the resource memory. The typical QML developer does not (and should not have to!) know about the internals of the engine. Still, given a demanding setup, the situation might arise where one needs at least a conceptual understanding of the implementation.</p>\n<p>The goal of this talk is to have a look into the black box “QML memory management” and to provide an overview on how it works internally. The talk will address questions such as:<br />\n- What for does the QML-engine need memory at all?<br />\n- Where do QML items live?<br />\n- How does the QML engine acquire its memory from the operating system?<br />\n- How is the memory managed which has been acquired by the engine?<br />\n- How does the garbage collector work?<br />\n- Why keeps the memory usage of my QML process growing?<br />\n- Why is it so hard to give memory back to the operating system?<br />\n- How has the QML memory management evolved over time - starting with Qt5.2 and introduction of the V4 engine up to today?<br />\n- What is the right tooling to profile QML memory usage?</p>\n<p>Understanding these topics provides the basis for informed design and architecture decisions. This is especially important when developing for memory constrained environments such as embedded systems. The talk will also present some hands-on tweaks and options on how to address certain problematic memory behaviors of the QML engine.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Frank Meerkötter",
      "organization": "basysKom GmbH",
      "bio": ""
    }
  },
  "749": {
    "id": 749,
    "presentation": {
      "title": "Effective QML",
      "abstract": "<p>Writing applications with QtQuick is, as implied by the name, quite easy, and can be done by anyone after a quick introduction to the technology. While quickly writing an application is simple, doing so in an comprehensive, maintainable extensible and efficient is an important topic, especially for large and complex programs.</p>\n<p>The talk will present 18 best practices, tips and tricks and other useful guidelines for developing QtQuick applications, learned from years of experience from working on multiple QtQuick projects.</p>\n<p>The tips will cover 4 different topics:<br />\nThe first topic deals with development tooling, showing some well-known tools like the QML profiler of Gammaray, in addition to lesser known tools such as qmllint or integrating debugging keyboard shortcuts into your application.<br />\nThe second topic helps with understanding how QML works, which includes looking at things like object ownership, item sizes and what happens when loading a QML file.<br />\nThe third and largest topic covers best practices for coding a QML application, discussing things like layering, the split between QML and C++, creating reusable components and how to achieve a declarative coding style.<br />\nThe last topic deals with performance and gives various tip on what to look out for when you want to keep your application quick.</p>\n<p>The best practices mentioned in this talk cover many areas and should contain something new or interesting for everyone, hopefully helping in the goal to strive for robust quality applications.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Thomas McGuire",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "750": {
    "id": 750,
    "presentation": {
      "title": "Are you testing enough? Qt application Quality Insurance.",
      "abstract": "<p>Have we fixed all bugs in our software? How many bugs are present in the first place? Even the latter question can be very hard to answer.</p>\n<p>Every non-trivial Qt application includes various UI controls and internal elements that can all have different states. Taking into account the asynchronous nature of events, threads, and even slot invocations, the number of possible combinations explodes quickly.</p>\n<p>Often it is neither economically acceptable nor technically feasible to test all combinations. Which ones to focus on? How many bugs may we miss by limiting our efforts?</p>\n<p>A popular metric for measuring the quality of our testing is code coverage. The most commonly used levels will be depicted and compared. Special attention will be paid to Qt-specifics like code generated by the Meta Object Compiler moc and related macros. And what about a user interface declared in QML? We will evaluate the idea of UI coverage.</p>\n<p>We will also look at approaches like \"monkey testing\" and \"fuzzing\" that promise to achieve a deeper test penetration without much extra effort. Or methologies like Pairwise Testing that help to reduce the number of combinations to test. Again, we will examine how well those techniques apply to a Qt GUI.</p>\n<p>For security critical applications, the quality of Qt itself needs to be taken into account. An overview of the development process including change reviews, unit tests and Continuous Integration (CI) will be given.</p>\n<p>In the end, developers and managers will have to deal with a degree of uncertaintity. Acceptance tests that verify high-level requirements in terms of user stories can help to concentrate on most critical functionality and therefore mitigate the risk of the unknown.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Harri Porten",
      "organization": "froglogic",
      "bio": ""
    }
  },
  "751": {
    "id": 751,
    "presentation": {
      "title": "Practical aspects of crash reporting, analytics and connectivity challenges of connected device development",
      "abstract": "<p>The session will go into technical details on what challenges were encountered during the development of a high-end optical heart-rate monitor device (PulseOn) and what technologies (both Qt and other) were used to overcome those challenges. The session will focus on three areas:</p>\n<p>- Analytics - an introduction to purely Qt-based open source analytics solution using Google Analytics as a back-end (without using any Google SDK or library). Code will be shown how to enable logging and tracking of user activities and various operational parameters of the device, and how it can be done for both QML and C++ code.</p>\n<p>- Crash reporting - how to create and utilize external crash reporting tools that work well with Qt even on mobile platforms (on the example of using CoffeeCatch on Android)</p>\n<p>- Connectivity - Bluetooth connectivity considerations, challenges, tips and tricks for interfacing with BT SPP and BT LE enabled connected devices (especially in the light of the new BT LE API launched with Qt5.4), and also SPI/I2C for smaller, wire-connected devices</p>\n<p>Finally, the three aspects will be demonstrated live on the example of the PulseOn data collection application and how they can make device development and deployment less guesswork and more a controlled process to develop quality hardware and software.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Attila Csipa",
      "organization": "PulseOn oy",
      "bio": ""
    }
  },
  "752": {
    "id": 752,
    "presentation": {
      "title": "Get to know the Qt Installer Framework",
      "abstract": "<p>The Qt libraries allow you to conveniently write code that runs on different platforms. However, the native channels for distributing your application (application stores, native installers, repository managers ...) do differ a lot, which makes shipping a complex application on different platforms a challenge.</p>\n<p>The Qt Installer Framework was developed to solve this issue for the Qt SDK. However, it is a generic framework that can be also used for any installer and updater that targets OS X, Windows or Linux. You can create purely offline, online, and mixed installers, and ship online updates without relying on third party services. It contains a full-blown dependency manager that manages to solve complex package dependencies. It's scripting capabilities allow you to tweak both the installer UI, as well as take additional actions on (un)installation.</p>\n<p>In the presentation we will outline the strengths and weaknesses of the Qt Installer Framework. In this hands-on part we will have a closer look at individual Qt Installer Framework capabilities, showing you how to solve the most common tasks. After the presentation you will be aware of what the Qt Installer Framework is and what its capabilities are. You will also be able to make an informed decision on whether to use it for a particular application.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Kai Köhne",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "753": {
    "id": 753,
    "presentation": {
      "title": "Custom Qt Creator Wizards",
      "abstract": "<p>Qt Creator introduced a new JSON based wizard framework in version 3.3, which has replaced most of the old wizards, coded in C++.</p>\n<p>This presentation demonstrates the new wizards, shows how to create your own wizards and also points out their limitations and how to get around those with C++ code.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Tobias Hunger",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "754": {
    "id": 754,
    "presentation": {
      "title": "Developing with Qt Location",
      "abstract": "<p>This presentation provides a technical introduction into the Qt Location API. </p>\n<p>This new module was released in Qt 5.5 as a technical preview and provides Mapping, Geocoding, Routing and Place features.</p>\n<p>A small QML application will be developed during this practical coding session. The main focus is on getting to know the various QML API elements and how they may be put together.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Laszlo Agocs",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "755": {
    "id": 755,
    "presentation": {
      "title": "Among ELFs and DWARFs",
      "abstract": "<p>When debugging a problem or optimizing performance we tend to look at the source code of our application and its runtime behavior. There is however a third form of our program we can look at that is far less often used for this purpose, the compiled binary. While this obviously isn't the right form to work with in many scenarios, it does provide us with valuable information when dealing with start-up performance, memory consumption, plug-in loading issues or bizarre runtime behavior for example.</p>\n<p>In this talk we will look at various useful information we can find in compiled libraries or executables, with a special focus on Qt related use-cases. Exploring a binary for example shows implications of Qt's various ways of dealing with string literals, how to debug Qt plug-in loading issues, or why member function pointer signal/slot connections can fail in surprising ways. We will also cover some of the tools available for inspecting binary files, relevant linker flags and their impact, and ways to look into the very early, pre-main phases of application runtime.</p>\n<p>As the title suggests examples will primarily focus on the ELF format used on Linux, Android and other UNIX systems as well as QNX, but due to their common ancestry you will find most concepts and ideas also applying to PE and Mach-O.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Volker Krause",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "756": {
    "id": 756,
    "presentation": {
      "title": "Creating multithreaded applications with Qt",
      "abstract": "<p>In Qt, there are a lot of options for building multithreaded applications: Using QThread directly, Qt Concurrent, QFuture etc.</p>\n<p>Given the multitude of options, it's common for developers to be confused about which one they should choose for certain problems. So they choose one of them, learn this one, and stay with it for all their threaded work. That's too bad, when Qt offers better tools for some of the code they are working on.</p>\n<p>For the desktop, most of us have systems with many cores, that would allow the applications to run much faster, if the developers can use those tools correctly. This is increasingly also the case for applications running on embedded systems, phones or tablets, as the newer processors have an increasing number of cores.</p>\n<p>I will go through those options, show how to use each of them, and give examples of what each of the solutions would be useful for. I will also talk about the performance implications of the different approaches. I will also discuss when to avoid threads and instead focus on using the power of the event driven programming that Qt offers.</p>\n<p>This will give the developer the information needed to make the right choice next time he is faced with the decision of what type of threading technology to use.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Bo Thorsen",
      "organization": "Viking Software",
      "bio": ""
    }
  },
  "757": {
    "id": 757,
    "presentation": {
      "title": "Reactive programming and Qt",
      "abstract": "<p>Reactive programming is an emerging discipline which achieves concurrency using events-based programming. Today, It is mostly used for writing very scalable web services that can achieve high concurrency levels even on a single thread.</p>\n<p>The concept is simple - make a system that is fully event-based, and look at events not as isolated instances, but as streams. When we have streams, we can manipulate them as if they were simple ranges. We can filter them, modify them, combine multiple streams into one etc.</p>\n<p>Reactive programming is not only applicable to the web services, it can be used in any event-based environment. In our case, in normal Qt applications, to enrich the power of signals and slots.</p>\n<p>The talk will consist of two parts. In the first part, ranges will be explained (through the boost.range library, and Eric Niebler's range library proposal for C++17). We will show that ranges, and range transformations are a natural extension to the <algorithm> library in STL, which allows writing more concise and safe code that deals with collection structures like lists, vectors or maps.</p>\n<p>The second part will deal with what reactive streams are, and their relation to ranges. We will show how to create streams using Qt's signals and slots mechanism, how to manipulate them, and connect the transformed streams back to the UI or other application components.</p>\n<p>We will show a multitude of examples of how this can make the code more composable, clean and more declarative.</p>\n<p>The examples will require some prior C++11/14 knowledge, while the features needed from the forthcoming C++17 standard will be explained.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Ivan Čukić",
      "organization": "KDE",
      "bio": ""
    }
  },
  "758": {
    "id": 758,
    "presentation": {
      "title": "Qt Value Class Design",
      "abstract": "<p>Qt is well-known for its excellent higher-level APIs, from QtQuick/QML over QtWidgets to the very central QObject class hierarchy. Consequently, this is what training material has rightfully been focused on. But holding together the fabric of JavaScript and C++ higher-level APIs is a plethora of value classes, that is, classes that are are designed to behave like built-in types such as int.</p>\n<p>You use these classes every day in your Qt work: From QString, QByteArray, QVariant over QSize, QPoint, QRect and their -F variants, to the collection classes such as QVector, QStringList and QHash, and finally drawing classes such as QColor, QPen, QBrush, QPolygon and QPainterPath. And that's just scratching the surface of QtCore and QtGui.</p>\n<p>Unlike polymorphic classes, which are designed for inheritance and gently guide your subclass design by the knobs they expose (protected and virtual members, say), value classes have to be designed from scratch each time one is needed.</p>\n<p>At the same time, value classes tend to affect the performance of your programs in more profound ways than polymorphic classes ever could. Who hasn't started out passing QStrings around by value instead of reference-to-const, and then wondered why QAtomicInt functions top the list of call counts, or even time spent in performance profile data?</p>\n<p>Likewise, failure to introduce a value class over a tuple of values (say, two ints instead of a Point class) makes for hard-to use (for humans) and hard-to-optimize (for compilers) APIs.</p>\n<p>In this presentation, we'll take a deep dive into value class design, in particular, but not exclusively, from a performance point of view. You will learn how your compiler sees your code and how you can level the playing field again. But we'll also cover API design and binary compatibility issues.</p>\n<p>We'll start by classifying the different approaches used to write value classes and then present specific guidelines for each of these. You will learn how to make your value classes compact and fast, easy to use, and extensible.</p>\n<p>The presentation targets an audience with intermediate to expert Qt knowledge. Some familiarity with features new in C++11/14 is highly beneficial, too. In particular, we will not explain the Qt classes that we use, and will only very briefly describe new C++11/14 feature we may be using in the code.</p>\n<p>Beginners are welcome, too, but may want to read up on the above-mentioned topics to get the maximum out of this presentation.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Marc Mutz",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "759": {
    "id": 759,
    "presentation": {
      "title": "Developer Unconference Track & Lightning Talks",
      "abstract": "<p>Coming soon</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Speaker to be announced",
      "organization": "",
      "bio": ""
    }
  },
  "760": {
    "id": 760,
    "presentation": {
      "title": "Closing Wrap-Up",
      "abstract": "<p>Closing remarks</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Speaker to be announced",
      "organization": "",
      "bio": ""
    }
  },
  "763": {
    "id": 763,
    "presentation": {
      "title": "Pre-conference Training: Introduction to QML – also known as Qt Quick",
      "abstract": "<p>Target Audience: Developers and managers interested in learning the autonomy of a QML application.</p>\n<p>Prerequisite: Knowing the basics of Qt at C++ level is an advantage but not a requirement.</p>\n<p>This training is an introduction to Qt Quick. On the one hand it will teach you how to compose fluid user interfaces with slick animations using the QML language. On the other hand it will teach you how you hook the QML side up to your business logic in C++.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Jesper Pedersen & Paul Lemire",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "765": {
    "id": 765,
    "presentation": {
      "title": "Pre-conference Training: Model/View programming in Qt",
      "abstract": "<p>Target Audience: Qt developers interested in model/view either from QML or from Qt Widgets.</p>\n<p>Prerequisite: Existing Qt knowledge.</p>\n<p>A key ingredient in successful software development is the separation of presentation and business logic. Everyone knows that. A larger part of most applications is a list of things, and for those, Qt offers such separation using a model/view framework.</p>\n<p>This presentation will introduce this framework and tell you how to develop models independent of whether they are to be displayed in a C++/Qt application or in a Qt Quick application.</p>\n<p>The training dive into subjects such as:</p>\n<p>- The API to implement for use in a 1 dimensional list, a 2 dimensional table and a tree view<br />\n- What model indexes are all about<br />\n- How to successfully implement a proxy model<br />\n- How to debug your models<br />\n- How to implement models in C++ that are displayed in Qt Quick.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Tobias König",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "767": {
    "id": 767,
    "presentation": {
      "title": "Pre-conference Training: Debugging and Profiling Qt applications",
      "abstract": "<p>Target Audience: Developers who want to find and fix problems</p>\n<p>Prerequisite: Knowing the basics of C++, Qt and QML</p>\n<p>This training gives an introduction to various tools, which help developers and testers in finding bugs and performance issues.</p>\n<p>The tools presented cover a wide range of problems, from general purpose debugging and CPU profiling to Qt specific high-level analyzers. Often, it is relatively simple to run a tool, but interpreting the results, or even just using some of the more advanced tools, requires deep technical knowledge.</p>\n<p>The most important tools on all major platforms that Qt supports, i.e. Linux, Windows, Mac OSX, iOS and Android, will be covered:</p>\n<p>debugging</p>\n<p>- general purpose debuggers: GDB, LLDB, Windows Debugging Tools<br />\n- memory error detectors: valgrind’s memcheck, Dr. Memory, AddressSanitizer<br />\n- thread error detectors: valgrind’s helgrind, ThreadSanitizer<br />\n- OpenGL: apitrace, XCode<br />\n- various Qt-builtin features for logging, QML, WebKit, WebEngine, DBUS etc.<br />\n- GammaRay to investigate internals of Qt applications</p>\n<p>profiling</p>\n<p>- CPU: valgrind’s callgrind, Linux perf, Intel® VTune™ Amplifier, Instruments, Visual Studio<br />\n- heap memory: valgrind’s massif, heaptrack, Instruments, Visual Studio<br />\n- OpenGL: apitrace, vogl, NVidia nSight, AMD CodeXL, Vivante vProfile</p>\n<p>testing</p>\n<p>- Qt TestLib: unit tests and benchmarks<br />\n- Squish: testing graphical<br />\n- static code analysis: qmllint, clang analyzer, coverity<br />\n- code coverage</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Volker Krause & Milian Wolff",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "770": {
    "id": 770,
    "presentation": {
      "title": "Pre-conference Training: Introduction to Multithreaded Programming with Qt",
      "abstract": "<p>Target Audience: Qt Developers interested in multithreaded development.</p>\n<p>Prerequisite: Existing Qt knowledge. Basic understanding of multithreaded programming is also an advantage.</p>\n<p>With more and more cores in computers, multithreaded programming is becoming increasingly important for developers. Qt offers several mechanisms for multithreading, however, it is up to you to decide which to use when so that you steer clear of common pitfalls.</p>\n<p>This training will introduce you to multithreading concepts in general, tell you about the different mechanism in Qt, and discuss best practices and common pitfalls.</p>\n<p>It is a requirement that you at least know the basics of Qt for this training.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Kevin Krammer",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "771": {
    "id": 771,
    "presentation": {
      "title": "Pre-conference Training: Introduction to Modern OpenGL with Qt",
      "abstract": "<p>Target Audience: Developers interested in learning the basics of OpenGL.</p>\n<p>Prerequisite: A basic level of linear algebra will be assumed for this course (multiplying a matrix and a vector). Mathematics will be kept to a bare minimum so as not to get in the way of eye candy!</p>\n<p>OpenGL is a central part of QtQuick2 in Qt 5 and also plays a key role in displaying the main content of many widget-based applications.</p>\n<p>OpenGL has been around for many years and in recent times has evolved to shed much of its legacy baggage and better expose the underlying hardware. Modern OpenGL allows us to take full advantage of the enormous power and parallel processing power of today’s GPUs. Maximizing performance of OpenGL rendering requires us to understand how GPUs work and how to efficiently feed them with data.</p>\n<p>Qt provides a number of classes to make life easier when working with modern OpenGL. This training will show you how to do the basic tasks associated with OpenGL rendering and will go on to show how to use Qt and OpenGL to achieve a number of rendering effects and algorithms. You will also learn how to write custom QtQuick2 items using the OpenGL and scene graph APIs.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Sean Harmer, Dr.",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "772": {
    "id": 772,
    "presentation": {
      "title": "Pre-conference Training: What’s new in C++11/C++14? (with a Qt5 focus)",
      "abstract": "<p>Target Audience: C++ developers who want to upgrade their C++ skills</p>\n<p>Prerequisite: Knowing the basics of C++ (the old standard) is a requirement, though more advanced topics will be explained as needed. Knowing the basics of Qt is beneficial, but not required.</p>\n<p>This training is targeted at people who are interested to combine the new features of C++11/C++14 with Qt5 (and, to a lesser extent, Qt 4.8). It will teach you all about the new C++11/C++14 features, but also throws in Qt-specific information, including how to structure your code so that a simple recompile with a C++14 compiler will make your applications both faster and use less memory.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Thomas McGuire",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "773": {
    "id": 773,
    "presentation": {
      "title": "Pre-conference Training: Qt for Mobile Platforms – Android/iOS",
      "abstract": "<p>Target Audience: Anyone interested in the process of developing with Qt for mobile platforms</p>\n<p>Prerequisite: Basic Qt knowledge is beneficial.</p>\n<p>This presentation will introduce the tools and processes needed to develop with Qt for mobile devices, including Android and iOS.</p>\n<p>The agenda for the day will approximately look like this:</p>\n<p>- Installing and setting up Qt for Android<br />\n- Installing and setting up Qt for iOS<br />\n- Use case: Targeting desktop and mobile devices using Qt<br />\n- Device independent development – how do you cope with devices of vastly different resolutions and screen density</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Mike Krus & BogDan Vatra",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "774": {
    "id": 774,
    "presentation": {
      "title": "Pre-conference Training: Introduction to Testing Qt applications with Squish",
      "abstract": "<p>Target Audience: Testers, Developers and Managers interested in how to automate testing of Qt applications.</p>\n<p>Prerequisite: Knowing the basics of Qt and especially software development is a benefit for this presentation.</p>\n<p>Unit testing will only take you so far when a graphics system is involved. If you want to be sure that the overall system works, then you need to blackbox test it too. The tool for automating that in the Qt world is Squish.</p>\n<p>Squish is a record and playback tool, that can be used as is, but to get the most out of it a more structural approach is suggested. This training will introduce Squish and the refactoring approach that KDAB has successfully implemented in multiple large organizations.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Tobias Nätterlund",
      "organization": "KDAB",
      "bio": ""
    }
  },
  "781": {
    "id": 781,
    "presentation": {
      "title": "Building a Web Application Framework with Qt",
      "abstract": "<p>Coming soon</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Speaker to be announced",
      "organization": "",
      "bio": ""
    }
  },
  "809": {
    "id": 809,
    "presentation": {
      "title": "QtMozEmbed: Embedding Gecko with Qt5",
      "abstract": "<p>QtMozEmbed is an open source project, started by Oleg Romashin, that is built upon Embedlite embedding API to embed the Gecko web browser engine to Qt applications.</p>\n<p>The QtMozEmbed can be divided into two main components; context and view.</p>\n<p>The context is the one that starts the Gecko web browser engine by starting the gecko message loop. Through the context API user can set and read preferences and subscribe to observe browser global JSON message for instance about download status.</p>\n<p>The view provides necessary APIs to implement basic browsing functions like loading urls, and going back and forth in web pages. In addition, it maps Qt events (mouse, touch, key, input, and focus) to gecko events or Embedlite embedding API calls. Furthermore, it provides low level asynchronous JSON API to register message listeners, receive messages from the engine, and respond to the messages. You can register to listen messages about alerts, warnings, confirms, prompts, authentication dialogs, password management, single and multi select, location request, and so forth. So the view component is not responsible for rendering web prompts only the web content itself.</p>\n<p>In this talk we focus to the low level JSON APIs provided by the QtMozEmbed that allows flexible integration to a QML user interface.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Siteshwar Vashisht, Red Hat & Raine Mäkeläinen, Jolla",
      "organization": "",
      "bio": ""
    }
  },
  "905": {
    "id": 905,
    "presentation": {
      "title": "Secure, Realtime Connectivity for Connected Devices & IoT",
      "abstract": "<p>When developing realtime applications in the lab, connectivity is fairly easy.  With a couple of devices and a server running on the back end, connectivity is seamless and low latent.  However, deploying in the wild to thousands and even millions of users simultaneously is a whole different ball game.<br />\nThis presentation will outline how thousands of developers use the PubNub Data Stream Network to enable secure, reliable, and high-speed 2-way communications across any number of connected devices, globally.  It will further address how to navigate network drop-offs with devices that may be turned off, out of power, or not ready for use.  Specific case examples will include Connected Car and Smart Home.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Dave Nugent",
      "organization": "PubNub",
      "bio": ""
    }
  },
  "915": {
    "id": 915,
    "presentation": {
      "title": "KEYNOTE: Qt Today and Tomorrow – The Building Blocks and Path to the Future",
      "abstract": "<p>As the CTO of The Qt Company and the Chief Maintainer of the Qt Project, Lars will give insight into how Qt is built, how the organization and community behind it works, and how all the pieces fall into place. In the past year, Qt has accomplished many great  things, but the main question now is; what will happen in the years to come? In his presentation, Lars will focus on where Qt is heading in the next few years and explain the vision and foundation of the Qt technology,  as well as the passion that drives the development. To end, Lars will highlight the Qt R&D focus areas and Qt functionalities to be expected in upcoming releases. </p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Lars Knoll, CTO",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "918": {
    "id": 918,
    "presentation": {
      "title": "KEYNOTE: The In-Car User Experience is the Next Competitive Battleground, and It Will be Software-Defined & Updateable",
      "abstract": "<p>The auto industry has historically relied upon Tier1 suppliers to provide fixed-function infotainment systems that meet a predefined set of functional, safety and reliability requirements. In recent years, automakers and Tier1s have introduced systems that support Internet connectivity via 3/4G cellular technology, to provide a variety of mobile entertainment applications. With this change, buyer expectations for the behavior of modern automobiles are shifting.</p>\n<p>Consumers expect new automotive infotainment systems to not only provide dynamic applications, but to behave more like other categories of connected devices — televisions, game consoles, residential music systems, etc. — that can be “updated” to continuously freshen the features and functionality over the life of the product. The only practical way for the automotive industry to support this new market requirement is through adoption of structured, platform-based tooling and workflows that implement each layer of their infotainment system in a carefully specified manner. The ideal approach must support each ecosystem participant, including the automaker, selected tier one system supplier, and both tier two and third party contributors.</p>\n<p>In this presentation, we will shed light on how automakers can address a new competitive imperative: the in-car user experience.</p>\n<p>With hundreds of passenger car models on the market competing on the virtues of safety, reliability, performance, fuel economy, appearance and overall value, it is clear that the automotive community has established an effective process to build competitive products. The in-car user experience is the next competitive battleground.</p>\n<p>Automakers are refining in-car features and interaction models for drivers, but the real innovation has only just begun, as the industry prepares for a new competition - the fight to create the ideal driver’s experience.  This war will be waged with software, dynamic updates and new interaction models. We will describe the new categories of software development tools, technologies and processes that automakers will acquire and use to build and manage each connected vehicle's user experience.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Jeff Payne, CEO",
      "organization": "OpenCar Inc.",
      "bio": ""
    }
  },
  "930": {
    "id": 930,
    "presentation": {
      "title": "Implementing Modern Design Patterns with Qt",
      "abstract": "<p>Complex applications like social media platforms or big data enterprise appliances have brought forward modern design patterns like Command Query Responsibility Segregation(CQRS, seehttp://cqrs.nu/Faq/command-query-responsibility-segregation) and Event Sourcing (ES, see http://cqrs.nu/Faq/event-sourcing). These patterns are usually implemented in environments where Java is the language of choice which may explain that  there are no C++ based implementations around, not to mention Qt-based implementations.<br />\nWe have created a proof of concept implementation of a CQRS/ES framework based on Qt/QML, we will present a demonstrator application which illustrates the different aspects of the patterns like Commands, Domain-Events, Event-Store, Repositories and Read Models. </p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Bogdan Ogrean & Michael Wagner",
      "organization": "",
      "bio": ""
    }
  },
  "935": {
    "id": 935,
    "presentation": {
      "title": "QtWebEngine – Taming the beast",
      "abstract": "<p>QtWebEngine let you access the features and raw power of a leading web browser platform (Chromium) through convenient Qt API. First released with Qt 5.4, Qt WebEngine features both a Qt Widget and a Qt Quick integration to render regions of dynamic web content. With Qt 5.5 and upcoming Qt 5.6,  we updated the included Chromium version, and added new API to allow a deeper integration into existing apps.</p>\n<p>In this hands-on talk we will have a look at what you should know to make the most out of QtWebEngine. We'll have a detailed look at how Qt WebEngine is integrated in the QWidget and QML graphics stacks, and how to make sure to get the best performance. We also learn about convenient ways to profile and debug the web part of your application. Finally, we will have a look at new APIs introduced in Qt 5.5 and the upcoming Qt 5.6 We will discuss best practices to integrate web content with the C+ and QML world; now and as we move into the future.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Kai Köhne",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "989": {
    "id": 989,
    "presentation": {
      "title": "KEYNOTE: Using Qt to Create a Cross-Target Integrated Luxury Audio Experience – Holoplot 3D Audio Wall",
      "abstract": "<p>The Holoplot system creates an entirely novel, high-end listening experience in three dimensions. From the embedded systems that drive the audio, to the desktop application that manages setup, customization and tuning of the installation to the tablet based user interface that the consumer interacts with, the software required is complex. Thanks to the power of Qt, used across the entire system, the small software team was able to build a compelling solution under very tight deadlines. This presentation will present the Holoplot system, explore some of the challenges involved in building it and highlight how they were overcome.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Andreas Schmid, Entrepreneur, Holoplot & Till Adam, Services Director, Managing Director, KDAB",
      "organization": "",
      "bio": ""
    }
  },
  "997": {
    "id": 997,
    "presentation": {
      "title": "KEYNOTE: Possibilities for an Innovative Tomorrow",
      "abstract": "<p>Stay tuned</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Juha Varelius, CEO & Petteri Holländer, Head of Product Management",
      "organization": "The Qt Company",
      "bio": ""
    }
  },
  "1005": {
    "id": 1005,
    "presentation": {
      "title": "KEYNOTE: Kenneth Cukier",
      "abstract": "<p>.</p>\n",
      "track": {}
    },
    "presenter": {
      "image": "",
      "name": "Kenneth Cukier, Author",
      "organization": "The Economist",
      "bio": ""
    }
  }
}